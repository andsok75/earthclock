<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="style.css">
  <title></title>
  <script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
  <script type="text/javascript">
    const svgViewBoxSize = 1000;

    const decimalOpt = {
        daysInWeek: 10,
        hoursInDay: 10,
        minutesInHour: 100,
        secondsInMinute: 100
    };
    const traditionalOpt = {
        daysInWeek: 7,
        hoursInDay: 24,
        minutesInHour: 60,
        secondsInMinute: 60
    }
    opt = decimalOpt;
    function secondsInDay() { return opt.hoursInDay*opt.minutesInHour*opt.secondsInMinute; }
    function traditionalMillisecondsInSecond() { return 24*60*60*1000/secondsInDay(); }  // 1000 if traditional system is used or 864 if decimal system is used

    let currentSunLineInitialized = false;
    let localNoonLineInitialized = false;

    let longitude = undefined;
    let secondOfDay = undefined;

    const projection = d3.geoOrthographic()
        .scale(svgViewBoxSize/2)
        .translate([svgViewBoxSize/2, svgViewBoxSize/2])
        .rotate(rotation(0));
    const path = d3.geoPath().projection(projection);
    const sunLine = d3.geoGraticule().step([360, 0]);
    function hourLines() { return d3.geoGraticule().step([360/opt.hoursInDay, 90]).extent([[-180, -89.6], [180, 89.6]]); }
    function hours() { return [...Array(opt.hoursInDay).keys()]; }
    function hourText(i) { return i; }

    window.onload = async function() {
        const text = await fetchgzip("countries.geojson.gz");
        console.log("parsing countries geojson");
        const countries = JSON.parse(text);
        addCountries(countries);
        addHourLines();
        console.log("running timers");
        setInterval(updateTime, traditionalMillisecondsInSecond()/10);
        setInterval(updateSun, traditionalMillisecondsInSecond());
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                longitude = position.coords.longitude;
                console.log(`obtained longitude ${longitude}`);
            }, function(error) {
                console.log(error);
            });
        }
    };

    function updateSystem() {
        const system = document.getElementById("select-system").value;
        secondOfDay = undefined;
        switch(system) {
            case "decimal":
                opt = decimalOpt;
                break;
            case "traditional":
                opt = traditionalOpt;
                break;
            default:
                throw Error(`unimpelemted system ${system}`);
        }
        addHourLines();
    }

    async function fetchgzip(url) {
        console.log(`fetching ${url}`);
        const response = await fetch(url);
        const compressedBlob = await response.blob();
        console.log(`unzipping ${url}`);
        const stream = compressedBlob.stream().pipeThrough(new DecompressionStream("gzip"));
        const blob = await new Response(stream).blob();
        return await blob.text();
    }

    function addCountries(countries) {
        d3.select("svg")
            .attr("viewBox", `0 0 ${svgViewBoxSize} ${svgViewBoxSize}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .attr("overflow", "visible");

        console.log("creating back countries");
        projection.rotate(rotation(0));
        projection.clipAngle(180);
        d3.select("svg").selectAll(".country-back").data(countries.features)
            .enter()
            .append("path")
            .attr("class", "country-back")
            .attr("d", path);
        console.log("creating front countries");
        projection.clipAngle(90);
        d3.select("svg").selectAll(".country").data(countries.features)
            .enter()
            .append("path")
            .attr("class", "country")
            .attr("d", path);
    }

    function addHourLines() {
        console.log("decorating globe");

        d3.selectAll(".hours").remove();
        d3.selectAll(".hours-back").remove();
        d3.selectAll(".hours-label").remove();

        projection.rotate(rotation(0));
        projection.clipAngle(180);
        d3.select("svg").insert("path", "path.country")
            .datum(hourLines())
            .attr("class", "hours-back")
            .attr("d", path);
        projection.clipAngle(90);
        d3.select("svg").insert("path", "path.sun")
            .datum(hourLines())
            .attr("class", "hours")
            .attr("d", path);

        d3.select("svg").selectAll(".text")
            .data(hours())
            .enter()
            .append("text")
            .text(function(i) { return i; })
            .attr("class", "hours-label")
            .attr("style", "text-anchor:middle;font-family:monospace;font-size:200%")
            .attr("dy", "1.25%")
            .attr("transform", function(i) {
                const p = projection([180-i*360/opt.hoursInDay, 0]);
                const f = 0.04;
                p[0] += f*(p[0]-svgViewBoxSize/2);
                p[1] += f*(p[1]-svgViewBoxSize/2);
                return `translate(${p})`;
            });
    }

    function updateSun() {
        if (secondOfDay === undefined) { return; }
        projection.rotate(rotation(180*(1-secondOfDay/(secondsInDay()/2))));

        if (!currentSunLineInitialized) {
            projection.clipAngle(180);
            d3.select("svg").insert("path", "path.country")
                .datum(sunLine)
                .attr("class", "sun-back")
                .attr("d", path);
            projection.clipAngle(90);
            d3.select("svg").insert("path")
                .datum(sunLine)
                .attr("class", "sun")
                .attr("d", path);
            currentSunLineInitialized = true;
        } else {
            projection.clipAngle(180);
            d3.select("svg").selectAll(".sun-back")
                .datum(sunLine)
                .attr("class", "sun-back")
                .attr("d", path);
            projection.clipAngle(90);
            d3.select("svg").selectAll(".sun")
                .datum(sunLine)
                .attr("class", "sun")
                .attr("d", path);
        }

        if (longitude === undefined) { return; }
        projection.rotate(rotation(longitude));

        if (!localNoonLineInitialized) {
            projection.clipAngle(180);
            d3.select("svg").insert("path", "path.country")
                .datum(sunLine)
                .attr("class", "local-noon-back")
                .attr("d", path);
            projection.clipAngle(90);
            d3.select("svg").insert("path")
                .datum(sunLine)
                .attr("class", "local-noon")
                .attr("d", path);
            localNoonLineInitialized = true;
        }
    }

    function rotation(roll, pitch=-90, yaw=0) {
        return [roll, pitch, yaw];
    }

    function updateTime() {
        // This function updates the time, that is UTC time expressed as years and days with decimal fractions.
        // The same time is also shown as decimal hours, minutes, and seconds in the current ten-day week.
        // It can show traditional time too if options are set to traditional values.
        //
        // The time at local noon is the UTC time at the moment when the mean sun passes the local medirian.
        // The local time is the time till local noon in the morning or since local noon in the evening.
        //
        // Note that the mean sun is usually different from the apparent sun, so apparent noon may be ahead or behind the mean noon by a few minutes.
        // For details, see https://en.wikipedia.org/wiki/Equation_of_time
        //
        // The following command yields a table showing decimal minutes from mean noon to apparent noon for each day of year 2024.
        // For instance, on day 40 the apparent noon occurs later than the mean noon by almost ten decimal minutes.
        // (YEAR=2024; curl -s "https://ssd.jpl.nasa.gov/api/horizons.api?format=text&COMMAND='10'&OBJ_DATA='NO'&MAKE_EPHEM='YES'&EPHEM_TYPE='OBSERVER'&CENTER='0,0,0@399'&START_TIME='"$YEAR"-01-01%2012:00'&STOP_TIME='"$YEAR"-12-31%2012:00'&STEP_SIZE='1%20d'&CSV_FORMAT='NO'&QUANTITIES='42'" | awk 'NR==1{printf "day minutes\n"}/\$\$SOE/{flag=1;next}/\$\$EOE/{flag=0}flag{h=$(NF-2);m=$(NF-1);s=$NF;eot=(h=="-00"?-1:1)*(m*60+s)*10/864; printf "%3d%7.2f\n",i++,-eot}' -)
        // For details, see https://ssd-api.jpl.nasa.gov/doc/horizons.html

        const date = new Date();
        const year = getYear(date);
        const dayOfYear = getDayOfYear(date);

        secondOfDay = getSecondOfDay(date);  // this global variable is also used in function to update sun line

        document.getElementById('time').innerHTML = `${year}/${dayOfYear.p(3)}.${secondOfDay.p(5)}`;

        const week = Math.trunc(dayOfYear/opt.daysInWeek);
        const time = getTimeFromSeconds(secondOfDay, dayOfYear%opt.daysInWeek);
        document.getElementById('timeColonized').innerHTML = `${time.hour}:${time.minute.p(2)}:${time.second.p(2)} of ${opt.daysInWeek}-day week ${week} of year ${year}`;

        if (longitude === undefined) { return; }

        // Longitude below is measured in seconds, as an integer ranging from 0 up to number of seconds in a day.
        // In decimal system, Greenwich meridian is at 50000 and Sydney is at 8000 seconds.
        const longitudeInSeconds = Math.trunc(secondsInDay()*(longitude+180)/360);
        const secondOfDayAtLocalNoon = secondsInDay()-longitudeInSeconds;
        const timeAtLocalNoon = getTimeFromSeconds(secondOfDayAtLocalNoon);
        const [secondsToLocalNoon, period] = getSecondsToLocalNoon(secondOfDay, secondOfDayAtLocalNoon);
        const localTime = getTimeFromSeconds(secondsToLocalNoon);
        document.getElementById('localTimeColonized').innerHTML = `${localTime.hour}:${localTime.minute.p(2)}:${localTime.second.p(2)} ${period} at ${timeAtLocalNoon.hour}:${timeAtLocalNoon.minute.p(2)}:${timeAtLocalNoon.second.p(2)}`;
    }

    function getYear(date) {
        return date.getUTCFullYear();
    }

    function getDayOfYear(date) {
        const y = date.getUTCFullYear();
        const m = date.getUTCMonth();
        const d = date.getUTCDate();
        // https://stackoverflow.com/questions/8619879/javascript-calculate-the-day-of-the-year-1-366
        return -1+m*31-(m>1?(1054267675>>m*3-6&7)-(y&3||!(y%25)&&y&15?0:1):0)+d;
    }

    function getSecondOfDay(date) {
        const ms = date.getUTCMilliseconds();
        const s = date.getUTCSeconds();
        const m = date.getUTCMinutes();
        const h = date.getUTCHours();
        return Math.trunc((ms+(s+(m+h*60)*60)*1000)/traditionalMillisecondsInSecond());
    }

    function getTimeFromSeconds(seconds, dayOfWeek=0) {
        const secondsInHour = opt.secondsInMinute*opt.minutesInHour;
        return {
            hour: dayOfWeek*opt.hoursInDay+Math.trunc(seconds/secondsInHour),
            minute: Math.trunc((seconds%secondsInHour)/opt.secondsInMinute),
            second: seconds%opt.secondsInMinute
        }
    }

    function getSecondsToLocalNoon(secondOfDay, secondOfDayAtLocalNoon) {
        const i = secondOfDay-secondOfDayAtLocalNoon;
        const n = secondsInDay();
        const secondsToLocalNoon = Math.abs(i) < n/2 ? Math.abs(i) : n-Math.abs(i);
        const period = (-n/2 <= i && i < 0) || n/2 <= i ? "till noon" : "since noon";
        return [secondsToLocalNoon, period];
    }

    Number.prototype.p = function(length) {
        return this.toString().padStart(length, '0')
    }
  </script>
  </head>
  <body>
    <div id="time"></div>
    <div id="timeColonized"></div>
    <div id="localTimeColonized"></div>
    <svg id="globe"></svg>
    <select name="system" id="select-system" onchange="updateSystem();">
      <option value="decimal" selected>Decimal</option>
      <option value="traditional">Traditional</option>
    </select>
</body>
</html>
