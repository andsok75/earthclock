<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="style.css">
  <title></title>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script type="text/javascript">
    const svgViewBoxSize = 1000;

    let globeCreated = false;
    let currentSunPathInitialized = false;
    let localNoonPathInitialized = false;

    let longitude = undefined;
    let secondOfDay = undefined;

    const projection = d3.geoOrthographic()
        .scale(svgViewBoxSize/2)
        .translate([svgViewBoxSize/2, svgViewBoxSize/2])
        .rotate(rotation(0));
    const path = d3.geoPath().projection(projection);
    const graticule = d3.geoGraticule().step([36, 90]);
    const sun = d3.geoGraticule().step([360, 0]);

    window.onload = function() {
        d3.json("countries.geojson", createGlobe);
        setInterval(updateTime, 87);
        setInterval(updateSun, 864);
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                longitude = position.coords.longitude;
            }, function(error) {
                console.log(error);
            });
        }
    };

    function createGlobe(countries) {
        d3.select("svg")
            .attr("viewBox", `0 0 ${svgViewBoxSize} ${svgViewBoxSize}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .attr("overflow", "visible");

        projection.clipAngle(180);
        d3.select("svg").selectAll(".country-back").data(countries.features)
            .enter()
            .append("path")
            .attr("class", "country-back")
            .attr("d", path);
        projection.clipAngle(90);
        d3.select("svg").selectAll(".country").data(countries.features)
            .enter()
            .append("path")
            .attr("class", "country")
            .attr("d", path);

        projection.clipAngle(180);
        d3.select("svg").insert("path", "path.country")
            .datum(graticule)
            .attr("class", "graticule-back")
            .attr("d", path);
        projection.clipAngle(90);
        d3.select("svg").insert("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);

        d3.select("svg").selectAll(".text")
            .data([...Array(10).keys()])
            .enter()
            .append("text")
            .text(function(d) { return d; })
            .attr("class", "label")
            .attr("style", "text-anchor:middle;font-size:200%")
            .attr("dy", "1.25%")
            .attr("transform", function(d) {
                const p = projection([180-d*36, 0]);
                const f = 0.03;
                p[0] += f*(p[0]-svgViewBoxSize/2);
                p[1] += f*(p[1]-svgViewBoxSize/2);
                return `translate(${p})`;
            });

        globeCreated = true;
    }

    function updateSun() {
        if (!globeCreated) { return; }

        if (secondOfDay === undefined) { return; }
        projection.rotate(rotation(180*(1-secondOfDay/50000)));

        if (!currentSunPathInitialized) {
            projection.clipAngle(180);
            d3.select("svg").insert("path", "path.country")
                .datum(sun)
                .attr("class", "sun-back")
                .attr("d", path);
            projection.clipAngle(90);
            d3.select("svg").insert("path")
                .datum(sun)
                .attr("class", "sun")
                .attr("d", path);
            currentSunPathInitialized = true;
        } else {
            projection.clipAngle(180);
            d3.select("svg").selectAll(".sun-back")
                .datum(sun)
                .attr("class", "sun-back")
                .attr("d", path);
            projection.clipAngle(90);
            d3.select("svg").selectAll(".sun")
                .datum(sun)
                .attr("class", "sun")
                .attr("d", path);
        }

        if (longitude === undefined) { return; }
        projection.rotate(rotation(longitude));

        if (!localNoonPathInitialized) {
            projection.clipAngle(180);
            d3.select("svg").insert("path", "path.country")
                .datum(sun)
                .attr("class", "local-noon-back")
                .attr("d", path);
            projection.clipAngle(90);
            d3.select("svg").insert("path")
                .datum(sun)
                .attr("class", "local-noon")
                .attr("d", path);
            localNoonPathInitialized = true;
        }
    }

    function rotation(roll, pitch=-90, yaw=0) {
        return [roll, pitch, yaw];
    }

    function updateTime() {
        // This function updates the time, that is UTC time expressed as years and days with decimal fractions.
        // The same time is also shown as decimal hours, minutes, and seconds in the current ten-day week.
        //
        // The time at local noon is the UTC time expressed in decimal units as above at the moment when the mean sun passes the local medirian.
        // The local time is the time to local noon expressed in decimal units.
        // The pm period tells you how much time has passed since noon, and the am period tells you how much time remains until noon.
        // For instance, 1:95:14am mean there are decimal 1 hour, 95 minutes and 14 seconds remaining until noon at the given longitude.
        //
        // Note that the mean sun is usually different from the apparent sun, so apparent noon may be ahead or behind the mean noon by a few minutes.
        // For details, see https://en.wikipedia.org/wiki/Equation_of_time
        //
        // The following command yields a table showing decimal minutes from mean noon to apparent noon for each day of year 2024.
        // For instance, on day 40 the apparent noon occurs later than the mean noon by almost ten decimal minutes.
        // (YEAR=2024; curl -s "https://ssd.jpl.nasa.gov/api/horizons.api?format=text&COMMAND='10'&OBJ_DATA='NO'&MAKE_EPHEM='YES'&EPHEM_TYPE='OBSERVER'&CENTER='0,0,0@399'&START_TIME='"$YEAR"-01-01%2012:00'&STOP_TIME='"$YEAR"-12-31%2012:00'&STEP_SIZE='1%20d'&CSV_FORMAT='NO'&QUANTITIES='42'" | awk 'NR==1{printf "day minutes\n"}/\$\$SOE/{flag=1;next}/\$\$EOE/{flag=0}flag{h=$(NF-2);m=$(NF-1);s=$NF;eot=(h=="-00"?-1:1)*(m*60+s)*10/864; printf "%3d%7.2f\n",i++,-eot}' -)
        // For details, see https://ssd-api.jpl.nasa.gov/doc/horizons.html

        const date = new Date();
        const year = getYear(date);
        const dayOfYear = getDayOfYear(date);

        secondOfDay = getDecimalSecondOfDay(date);

        document.getElementById('time').innerHTML = `${year}/${dayOfYear.p(3)}.${secondOfDay.p(5)}`;

        const tenDayTime = {
            year: year,
            week: Math.trunc(dayOfYear/10),
            ...getTimeFromDecimalSeconds(secondOfDay, dayOfYear%10)
        };

        document.getElementById('tenDayTime').innerHTML = `${tenDayTime.hour.p(2)}:${tenDayTime.minute.p(2)}:${tenDayTime.second.p(2)} of week ${tenDayTime.week} of year ${tenDayTime.year}`;

        if (longitude === undefined) { 
            document.getElementById('localTime').innerHTML = "&nbsp;";
            return;
        }

        // Longitude below is measured in decimal seconds, as an integer ranging from 0 up to 100000.
        // Greenwich meridian is at 50000 and Sydney is at 92000 decimal seconds.
        const longitudeInSeconds = Math.trunc(100000*(longitude+180)/360);
        const secondOfDayAtLocalNoon = 100000-longitudeInSeconds;
        const timeAtLocalNoon = getTimeFromDecimalSeconds(secondOfDayAtLocalNoon);
        const [secondsToLocalNoon, period] = getSecondsToLocalNoon(secondOfDay, secondOfDayAtLocalNoon);
        const localTime = {
            ...getTimeFromDecimalSeconds(secondsToLocalNoon),
            period: period
        };
        document.getElementById('localTime').innerHTML = `${localTime.hour}:${localTime.minute.p(2)}:${localTime.second.p(2)}${localTime.period} at ${timeAtLocalNoon.hour}:${timeAtLocalNoon.minute.p(2)}:${timeAtLocalNoon.second.p(2)} (${longitude.toFixed(3)}&deg;)`;
    }

    function getYear(date) {
        return date.getUTCFullYear();
    }

    function getDayOfYear(date) {
        const y = date.getUTCFullYear();
        const m = date.getUTCMonth();
        const d = date.getUTCDate();
        // https://stackoverflow.com/questions/8619879/javascript-calculate-the-day-of-the-year-1-366
        return -1+m*31-(m>1?(1054267675>>m*3-6&7)-(y&3||!(y%25)&&y&15?0:1):0)+d;
    }

    function getDecimalSecondOfDay(date) {
        const ms = date.getUTCMilliseconds();
        const s = date.getUTCSeconds();
        const m = date.getUTCMinutes();
        const h = date.getUTCHours();
        // 864 is the number of milliseconds in a decimal second, 24*60*60*1000/(10*100*100).
        return Math.trunc((ms+(s+(m+h*60)*60)*1000)/864);
    }

    function getTimeFromDecimalSeconds(seconds, dayOfWeek=0) {
        // There are 100 decimal seconds in a decimal minute, 100 decimal minutes in a decimal hour, and
        // 10 decimal hours in a day or 100 decimal hours in a ten-day week.
        // Thus there are one million decimal seconds in a ten-day week.
        return {
            hour: dayOfWeek*10+Math.trunc(seconds/10000),
            minute: Math.trunc((seconds%10000)/100),
            second: seconds%100
        }
    }

    function getSecondsToLocalNoon(secondOfDay, secondOfDayAtLocalNoon) {
        const s = secondOfDay-secondOfDayAtLocalNoon;
        const secondsToLocalNoon = -50000 < s && s < 50000 ? Math.abs(s) : 100000-Math.abs(s);
        const period = (-50000 <= s && s < 0) || 50000 <= s ? "am" : "pm";
        return [secondsToLocalNoon, period];
    }

    Number.prototype.p = function(length) {
        return this.toString().padStart(length, '0')
    }
  </script>
  </head>
  <body>
    <div id="time"></div>
    <div id="tenDayTime"></div>
    <div id="localTime"></div>
    <svg id="globe"></svg>
  </body>
</html>
