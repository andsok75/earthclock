<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="style.css">
  <title></title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js" type="text/javascript"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson@3/dist/topojson.min.js" type="text/javascript"></script>
  <script type="text/javascript">
    const systems = [
        {
            name: "octal",
            base: 8,
            daysInWeek: 8,
            hoursInDay: 8,
            minutesInHour: 64,
            secondsInMinute: 64,
            secondsInHour: 64*64,
            secondsInDay: 8*64*64
        },
        {
            name: "decimal",
            base: 10,
            daysInWeek: 10,
            hoursInDay: 10,
            minutesInHour: 100,
            secondsInMinute: 100,
            secondsInHour: 100*100,
            secondsInDay: 10*100*100
        },
        {
            name: "base12",
            base: 12,
            daysInWeek: 12,
            hoursInDay: 12,
            minutesInHour: 144,
            secondsInMinute: 144,
            secondsInHour: 144*144,
            secondsInDay: 12*144*144
        },
        {
            name: "base14",
            base: 14,
            daysInWeek: 14,
            hoursInDay: 14,
            minutesInHour: 196,
            secondsInMinute: 196,
            secondsInHour: 196*196,
            secondsInDay: 14*196*196
        },
        {
            name: "hex",
            base: 16,
            daysInWeek: 16,
            hoursInDay: 16,
            minutesInHour: 256,
            secondsInMinute: 256,
            secondsInHour: 256*256,
            secondsInDay: 16*256*256
        },
        {
            // Besides inconsistent bases, another peculiarity about traditional system is that the week is not reset at the beginning of the year.
            // The first and the last weeks of the year may be incomplete because some days of the week may be spilled over to the previous or next year.
            // In the other systems, each year starts with week 0 and day 0, while the last week of the year is allowed to be incomplete.
            name: "traditional",
            base: 10,
            daysInWeek: 7,
            hoursInDay: 24,
            minutesInHour: 60,
            secondsInMinute: 60,
            secondsInHour: 60*60,
            secondsInDay: 24*60*60
        }
    ]
    const decimalSystem = systems.find(system => system.name === "decimal");
    const svgViewBoxSize = 1000;
    const projection = d3.geoOrthographic()
        .scale(svgViewBoxSize/2)
        .translate([svgViewBoxSize/2, svgViewBoxSize/2])
        .rotate(rotation());
    const path = d3.geoPath().projection(projection);
    const meridian = d3.geoGraticule().step([360, 0]);

    function rotation(roll=0, pitch=-90, yaw=0) { return [roll, pitch, yaw]; }

    let userSelectedSystem = undefined;
    let userLongitude = undefined;
    let previousSunLongitude = undefined;

    window.onload = async function() {
        console.time("onload");
        const countries = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json");
        addCountries(countries);
        updateHourMeridians(decimalSystem);
        setInterval(updateTime, 1000/60);
        createSystemSelection();
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                userLongitude = position.coords.longitude;
                addUserMeridian(userLongitude);
                console.log(`user longitude ${userLongitude}`);
            }, function(error) {
                console.log(error);
            });
        }
        console.timeEnd("onload");
    };

    function createSystemSelection() {
        const select = document.createElement("select");
        select.id = "select-system";
        select.setAttribute("autocomplete", "off");
        select.setAttribute("onchange", "updateSystem();");
        document.body.appendChild(select);
        for (const system of systems) {
            const option = document.createElement("option");
            option.value = system.name;
            option.text = system.name;
            if (system.name === decimalSystem.name) {
                option.setAttribute("selected", "selected");
            }
            select.add(option);
        }
    }

    function updateSystem() {
        const userSelectedSystemName = document.getElementById("select-system").value;
        userSelectedSystem = systems.find(system => system.name === userSelectedSystemName);
        updateHourMeridians(userSelectedSystem);
    }

    function addCountries(countries) {
        const svg = d3.select("svg")
            .attr("viewBox", `0 0 ${svgViewBoxSize} ${svgViewBoxSize}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .attr("overflow", "visible");
        const features = topojson.feature(countries, countries.objects.countries).features;
        projection.rotate(rotation());
        projection.clipAngle(180);
        svg.selectAll(".country-back").data(features)
            .enter()
            .insert("path")
            .attr("class", "country-back")
            .attr("d", path);
        projection.clipAngle(90);
        svg.selectAll(".country").data(features)
            .enter()
            .insert("path")
            .attr("class", "country")
            .attr("d", path);
        svg.insert("path")
            .datum({type: "Sphere"})
            .attr("class", "sphere-outline")
            .attr("d", path);
    }

    function updateHourMeridians(system) {
        projection.rotate(rotation());
        meridians = d3.geoGraticule().step([360/system.hoursInDay, 0]).extent([[-180, -89.6], [180, 89.6]]);
        svg = d3.select("svg");

        d3.selectAll(".hour-meridian").remove();
        d3.selectAll(".hour-meridian-back").remove();
        d3.selectAll(".hour-meridian-label").remove();

        projection.clipAngle(180);
        svg.insert("path", "path.country")
            .datum(meridians)
            .attr("class", "hour-meridian-back")
            .attr("d", path);
        projection.clipAngle(90);
        svg.insert("path", "path.sun-meridian")
            .datum(meridians)
            .attr("class", "hour-meridian")
            .attr("d", path);

        svg.selectAll(".text")
            .data([...Array(system.hoursInDay).keys()])
            .enter()
            .insert("text", "path.country")
            .text(function(i) { return i.s(system.base); })
            .attr("class", "hour-meridian-label")
            .attr("style", "text-anchor:middle;font-family:monospace;font-size:600%")
            .attr("dy", "3%")
            .attr("transform", function(i) {
                const p = projection([180-i*360/system.hoursInDay, 0]);
                const f = 0.06;
                p[0] += f*(p[0]-svgViewBoxSize/2);
                p[1] += f*(p[1]-svgViewBoxSize/2);
                return `translate(${p})`;
            });
    }

    function updateSunMeridian(sunLongitude) {
        projection.rotate(rotation(sunLongitude));
        const svg = d3.select("svg");
        if (previousSunLongitude === undefined) {
            projection.clipAngle(180);
            svg.insert("path", "path.country")
                .datum(meridian)
                .attr("class", "sun-meridian-back")
                .attr("d", path);
            projection.clipAngle(90);
            svg.insert("path")
                .datum(meridian)
                .attr("class", "sun-meridian")
                .attr("d", path);
        } else {
            projection.clipAngle(180);
            svg.selectAll(".sun-meridian-back")
                .datum(meridian)
                .attr("class", "sun-meridian-back")
                .attr("d", path);
            projection.clipAngle(90);
            svg.selectAll(".sun-meridian")
                .datum(meridian)
                .attr("class", "sun-meridian")
                .attr("d", path);
        }
        previousSunLongitude = sunLongitude;
    }

    function addUserMeridian(userLongitude) {
        projection.rotate(rotation(userLongitude));
        projection.clipAngle(180);
        const svg = d3.select("svg");
        svg.insert("path", "path.country")
            .datum(meridian)
            .attr("class", "user-meridian-back")
            .attr("d", path);
        projection.clipAngle(90);
        svg.insert("path", "path.sun-meridian")
            .datum(meridian)
            .attr("class", "user-meridian")
            .attr("d", path);
    }

    function updateTime() {
        // This function updates the time, that is UTC time expressed as years and days with decimal fractions.
        // The same time is also shown as decimal hours, minutes, and seconds in the current ten-day week.
        // The time will be shown with traditional or other units instead if the user selects another system.
        //
        // The time at user noon is the UTC time at the moment when the mean sun passes the user medirian.
        // The user time is the time till user noon in the morning (am period) or since user noon in the afternoon (pm period).
        //
        // Note that the mean sun is usually different from the apparent sun, so apparent noon may be ahead or behind the mean noon by a few minutes.
        // For details, see https://en.wikipedia.org/wiki/Equation_of_time
        //
        // The following command yields a table showing decimal minutes from mean noon to apparent noon for each day of year 2024.
        // For instance, on day 40 the apparent noon occurs later than the mean noon by almost ten decimal minutes.
        // (YEAR=2024; curl -s "https://ssd.jpl.nasa.gov/api/horizons.api?format=text&COMMAND='10'&OBJ_DATA='NO'&MAKE_EPHEM='YES'&EPHEM_TYPE='OBSERVER'&CENTER='0,0,0@399'&START_TIME='"$YEAR"-01-01%2012:00'&STOP_TIME='"$YEAR"-12-31%2012:00'&STEP_SIZE='1%20d'&CSV_FORMAT='NO'&QUANTITIES='42'" | awk 'NR==1{printf "day minutes\n"}/\$\$SOE/{flag=1;next}/\$\$EOE/{flag=0}flag{h=$(NF-2);m=$(NF-1);s=$NF;eot=(h=="-00"?-1:1)*(m*60+s)*10/864; printf "%3d%7.2f\n",i++,-eot}' -)
        // For details, see https://ssd-api.jpl.nasa.gov/doc/horizons.html

        const date = new Date();

        const year = getYear(date);
        const dayOfYear = getDayOfYear(date);

        const decimalSecondOfDay = getSecondOfDay(decimalSystem, date);
        document.getElementById('time').innerHTML = `${year.p(4, decimalSystem.base)}/${dayOfYear.p(3, decimalSystem.base)}.${decimalSecondOfDay.p(5, decimalSystem.base)}`;

        const system = Object.assign({}, userSelectedSystem || decimalSystem);  // fix the system for consistency
        const base = system.base;
        const secondOfDay = getSecondOfDay(system, date);

        const offset = system.name !== "traditional" ? 0 : new Date(Date.UTC(year, 0)).getUTCDay()-1;
        const week = Math.trunc((dayOfYear+offset)/system.daysInWeek);
        const dayOfWeek = (dayOfYear+offset)%system.daysInWeek;
        const time = getTimeFromSeconds(system, secondOfDay, dayOfWeek);
        document.getElementById('timeColonized').innerHTML = `${time.hour.s(base)}:${time.minute.p(2, base)}:${time.second.p(2, base)}&nbsp;of&nbsp;week&nbsp;${week.s(base)}`;

        const sunLongitude = 180*(1-secondOfDay/(system.secondsInDay/2));
        if( previousSunLongitude === undefined || Math.abs(sunLongitude-previousSunLongitude) > 0.1) {
            updateSunMeridian(sunLongitude);
        }

        if (userLongitude === undefined) {
            document.getElementById('userTimeColonized').innerHTML = "&nbsp;";
            return;
        }

        // Longitude below is measured in seconds, as an integer ranging from 0 up to number of seconds in a day.
        // In decimal system, Greenwich meridian is at 50000 and Sydney is at 8000 seconds.
        const userLongitudeInSeconds = Math.trunc(system.secondsInDay*(userLongitude+180)/360);
        const secondOfDayAtUserNoon = system.secondsInDay-userLongitudeInSeconds;
        const timeAtUserNoon = getTimeFromSeconds(system, secondOfDayAtUserNoon);
        const [secondsToUserNoon, period] = getSecondsToUserNoon(system, secondOfDay, secondOfDayAtUserNoon);
        const userTime = getTimeFromSeconds(system, secondsToUserNoon);
        document.getElementById('userTimeColonized').innerHTML = `${userTime.hour.s(base)}:${userTime.minute.p(2, base)}<span class="period">${period}</span>&nbsp;at&nbsp;${timeAtUserNoon.hour.s(base)}:${timeAtUserNoon.minute.p(2, base)}`;
    }

    Number.prototype.s = function(base=10) { return this.toString(base); }
    Number.prototype.p = function(length, base=10) { return this.toString(base).padStart(length, '0'); }

    function getYear(date) {
        return date.getUTCFullYear();
    }

    function getDayOfYear(date) {
        const y = date.getUTCFullYear();
        const m = date.getUTCMonth();
        const d = date.getUTCDate();
        // https://stackoverflow.com/questions/8619879/javascript-calculate-the-day-of-the-year-1-366
        return -1+m*31-(m>1?(1054267675>>m*3-6&7)-(y&3||!(y%25)&&y&15?0:1):0)+d;
    }

    function getSecondOfDay(system, date) {
        const ms = date.getUTCMilliseconds();
        const s = date.getUTCSeconds();
        const m = date.getUTCMinutes();
        const h = date.getUTCHours();
        const traditionalMillisecondsInSecond = 24*60*60*1000/system.secondsInDay;  // 1000 if traditional system is used or 864 if decimal system is used
        return Math.trunc((ms+(s+(m+h*60)*60)*1000)/traditionalMillisecondsInSecond);
    }

    function getTimeFromSeconds(system, seconds, dayOfWeek=0) {
        return {
            hour: dayOfWeek*system.hoursInDay+Math.trunc(seconds/system.secondsInHour),
            minute: Math.trunc((seconds%system.secondsInHour)/system.secondsInMinute),
            second: seconds%system.secondsInMinute
        }
    }

    function getSecondsToUserNoon(system, secondOfDay, secondOfDayAtUserNoon) {
        const i = secondOfDay-secondOfDayAtUserNoon;
        const n = system.secondsInDay;
        const secondsToUserNoon = Math.abs(i) < n/2 ? Math.abs(i) : n-Math.abs(i);
        const period = (-n/2 <= i && i < 0) || n/2 <= i ? "am" : "pm";
        return [secondsToUserNoon, period];
    }
  </script>
  </head>
  <body>
    <div id="time"></div>
    <div id="timeColonized"></div>
    <div id="userTimeColonized"></div>
    <svg id="globe"></svg>
</body>
</html>
